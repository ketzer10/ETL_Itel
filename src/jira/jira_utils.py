import requests
import json
import numpy as np
from requests.auth import HTTPBasicAuth


dsi_users = [
'stiven.cabrera@itelinternational.com',
'cristian.cano@itelinternational.com',
'alejandra.castillo@itelinternational.com',
'andres.diosa@itelinternational.com',
'sebastian.franco@itelinternational.com',
'alba.haschke@itelinternational.com',
'lucia.lopez@itelinternational.com',
'marlon.mendez@itelinternational.com',
'diego.naranjo@itelinternational.com',
'johana.balbuena@itelinternational.com',
'juan.orozco@itelinternational.com',
'camila.ortiz@itelinternational.com',
'santiago.perez@itelinternational.com',
'david.sanchez@itelinternational.com',
'katerine.urbano@itelinternational.com',
'maria.tobon@itelinternational.com',
'david.nolasco@itelinternational.com',
'rene.hernandez@itelinternational.com',
'laura.lastra@itelinternational.com',
'andres.sanchez@itelinternational.com',
'reporting@itelinternational.com',
'maira.vargas@itelinternational.com',
'alejandro.arenas@itelinternational.com'
]

def get_all_projects(user: str, token: str, jira_domain: str) -> dict:
    """It makes a GET request to the Jira API and get all the paginated projects

    Args:
        user (str): itel email registered in Jira.
        token (str): Token generated by Atlassian using the itel account.
        jira_domain (str): itel domain for Jira.

    Returns:
        json: Dictionary with all the projects information.
    """
    print(f"Getting all the available projects of {jira_domain} from the Atlassian Jira API...")
    url = f"https://{jira_domain}.atlassian.net/rest/api/3/project/search"
    auth = HTTPBasicAuth(user, token)

    headers = {
        "Accept": "application/json"
    }

    response = requests.request("GET", url, headers=headers, auth=auth)
    if response.status_code == 200:
        print("Projects obtained!")
        paginated_projects = json.loads(response.text)

    return paginated_projects["values"]

def get_needed_details_of_all_projects(paginated_projects: list) -> list:
    """It gets details of each project and it stores it within a dictionary.
    It returns a list with many dictionaries where each dictionary represents a project
    and each dictionary's key is an attribute of the projects.
    

    Args:
        paginated_projects (dict): Dictionary with all the projects

    Returns:
        list: list with many dictionaries where each dictionary represents a project
            and each dictionary's key is an attribute of the projects.
    """
    print("Extracting needed details of all projects...")
    projects = []
    for project in paginated_projects:
        project_dicc = {}
        project_dicc["id"] = project.get("id", np.nan)
        project_dicc["project_key"] = project.get("key", np.nan)
        project_dicc["name"] = project.get("name", np.nan)
        project_dicc["type_key"] = project.get("projectTypeKey", np.nan)
        project_dicc["style"] = project.get("style", np.nan)
        project_dicc["entity_id"] = project.get("entityId", np.nan)
        projects.append(project_dicc)
    
    return sorted(projects, key=lambda x: x["name"]) # Sort the user_diccs within the list by the name of the user

def get_all_users(user: str, token: str, jira_domain: str) -> dict:
    url = f"https://{jira_domain}.atlassian.net/rest/api/3/users/search"

    auth = HTTPBasicAuth(user, token)

    headers = {
        "Accept": "application/json"
    }
    
    query = {
        "maxResults": 1000
    }

    response = requests.request("GET", url, headers=headers, auth=auth, params=query)
    
    all_users = json.loads(response.text)
    
    return all_users

def get_needed_details_of_all_users(all_users: dict, current_dsi_users: list):
    dsi_users = []
    for user in all_users:
        user_dicc = {}
        user_dicc["account_id"] = user.get("accountId", np.nan)
        user_dicc["name"] = user.get("displayName", np.nan)
        user_dicc["email"] = user.get("emailAddress", np.nan)
        user_dicc["is_active"] = user.get("active")
        user_dicc["is_from_dsi"] = True if user_dicc["email"] in current_dsi_users else False
        dsi_users.append(user_dicc)
    
    return sorted(dsi_users, key=lambda x: x["name"]) # Sort the tuples by the names of the users

def get_all_boards_per_project(jira_domain: str, user: str, token: str, projectid_or_key: str):
    print(f"Getting all the available boards for project {projectid_or_key} of {jira_domain} from the Atlassian Jira API...")
    base_url = f"https://{jira_domain}.atlassian.net/rest/agile/1.0"
    headers = {
        "Accept": "application/json"
    }

    query_params = {
        "maxResults": 50,
        "projectKeyOrId": projectid_or_key
    }

    auth = HTTPBasicAuth(user, token)
    response = requests.get(f"{base_url}/board", headers=headers, params=query_params, auth=auth)

    if response.status_code == 200:
        all_boards_per_project = json.loads(response.text)
        return all_boards_per_project["values"]
    
    else:
        return []


def get_needed_details_of_all_boards(jira_domain: str, user: str, token:str, all_projects: list):
    all_boards = []
    for project in all_projects:
        project_id = project[0]
        boards = get_all_boards_per_project(jira_domain, user, token, project_id)
        if len(boards) >= 1:
            print("Board id obtained!")
            print("Getting board details...")
            for board in boards:
                board_dicc = {}
                board_dicc["id"] = board.get("id")
                board_dicc["project_id"] = project_id
                board_dicc["name"] = board.get("name")
                board_dicc["type"] = board.get("type")
                all_boards.append(board_dicc)
        else:
            print(f"No boards found!")
            continue
    
    return all_boards


def get_all_sprints_per_board(user: str, token: str, jira_domain: str, board_id: str):
    print(f"Getting all the available sprints ids for board {board_id} of {jira_domain} from the Atlassian Jira API...")
    base_url = f"https://{jira_domain}.atlassian.net/rest/agile/1.0"
    auth = HTTPBasicAuth(user, token)
    headers = {
        "Accept": "application/json"
    }

    # Parámetros de consulta
    query_params = {
        "maxResults": 100
    }


    response = requests.get(f"{base_url}/board/{board_id}/sprint", auth=auth, headers=headers, params=query_params)

    if response.status_code == 200:
        sprints = response.json()["values"]
        # for sprint in sprints:
        #     print(f"Sprint ID: {sprint['id']}, Sprint Name: {sprint['name']}, State: {sprint['state']}")
    else:
        # print(f"Error: {response.status_code} - {response.text}")
        sprints = []
    
    return sprints

def get_needed_details_of_all_sprints(jira_domain: str, user: str, token:str,  all_boards_ids: list):
    all_sprints = []
    for board in all_boards_ids:
        board_id = board[0]
        sprints = get_all_sprints_per_board(user, token, jira_domain, board_id)
        if len(sprints) >= 1:
            print("Sprint id obtained!")
            print("Getting sprint details...")
            for sprint in sprints:
                sprint_dicc = {}
                sprint_dicc["id"] = sprint.get("id")
                sprint_dicc["board_id"] = board_id
                sprint_dicc["name"] = sprint.get("name")
                sprint_dicc["state"] = sprint.get("state")
                sprint_dicc["start_date"] = sprint.get("startDate")
                sprint_dicc["end_date"] = sprint.get("endDate")
                sprint_dicc["complete_date"] = sprint.get("completeDate")
                all_sprints.append(sprint_dicc)
        else:
            print(f"No sprints found!")
            continue
    
    return all_sprints


def get_all_issues_per_sprint(user: str, token: str, jira_domain: str, sprint_id: str):
    base_url = f"https://{jira_domain}.atlassian.net/rest/agile/1.0"
    auth = HTTPBasicAuth(user, token)
    headers = {
        "Accept": "application/json"
    }

    # Parámetros de consulta
    query_params = {
        "startAt": 0,
        "maxResults": 100
    }


    response = requests.get(f"{base_url}/sprint/{sprint_id}/issue", auth=auth, headers=headers, params=query_params)

    if response.status_code == 200:
        issues = response.json()["issues"]
        # for sprint in sprints:
        #     print(f"Sprint ID: {sprint['id']}, Sprint Name: {sprint['name']}, State: {sprint['state']}")
    else:
        # print(f"Error: {response.status_code} - {response.text}")
        issues = []
    
    return issues

def get_all_issues_per_board(user: str, token: str, jira_domain: str, board_id: str):
    base_url = f"https://{jira_domain}.atlassian.net/rest/agile/1.0"
    auth = HTTPBasicAuth(user, token)
    headers = {
        "Accept": "application/json"
    }

    # Parámetros de consulta
    query_params = {
        "startAt": 0,
        "maxResults": 1000
    }


    response = requests.get(f"{base_url}/board/{board_id}/issue", auth=auth, headers=headers, params=query_params)

    if response.status_code == 200:
        issues = response.json()["issues"]
        # for board in sprints:
        #     print(f"Sprint ID: {sprint['id']}, Sprint Name: {sprint['name']}, State: {sprint['state']}")
    else:
        # print(f"Error: {response.status_code} - {response.text}")
        issues = []
    
    return issues


def get_needed_details_of_all_issues(jira_domain: str, user: str, token: str, all_sprints: list):
    all_issues = []
    for sprint in all_sprints:
        sprint_id = sprint[0]
        board_id = sprint[1]
        story_point_field = sprint[2]
        print(f"Getting all issues from sprint {sprint_id} and board {board_id}")
        issues = get_all_issues_per_sprint(user, token, jira_domain, sprint_id)
        print(f"Data obtained!")
        for issue in issues:
            issue_dicc = {}
            issue_dicc["id"] = issue.get("id")
            issue_dicc["issue_key"] = issue.get("key")
            issue_dicc["sprint_id"] = sprint_id
            issue_dicc["board_id"] = board_id
            issue = issue["fields"]
            issue_dicc["created"] = issue.get("created")
            issue_dicc["last_updated"] = issue.get("updated")
            issue_dicc["name"] = issue.get("summary", np.nan)
            issue_type = issue.get("issuetype")
            issue_dicc["type"] = issue_type.get("name", np.nan)
            status = issue.get("status")
            status_category = status.get("statusCategory")
            issue_dicc["status_category"] = status_category.get("name")
            issue_dicc["status"] = status.get("name")
            priority = issue.get("priority")
            issue_dicc["priority"] = priority.get("name")
            assignee = issue.get("assignee")
            issue_dicc["story_points"] = issue.get(story_point_field)
            issue_dicc["assignee_id"] = assignee.get("accountId", np.nan) if assignee != None else np.nan
            epic = issue.get("epic", np.nan)
            issue_dicc["epic_name"] = epic.get("name", np.nan) if epic != None else np.nan
            all_issues.append(issue_dicc)
    
    return all_issues

def get_needed_data_by_query(conn, query_data):
    print(f"Getting data from the db using this query: {query_data}")
    cursor = conn.cursor()
    cursor.execute(query_data)
    needed_data = [row for row in cursor.fetchall()]
    conn.close()
    print("Data obtained!")
    
    return needed_data

def construct_map_table(df, df_column):
    unique_values = df[df_column].unique().tolist()
    data_map_table = []
    dicc_to_replace = {}
    i = 1
    for value in unique_values:
        dicc = {}
        dicc["id"] = i
        dicc[df_column] = value
        data_map_table.append(dicc)
        dicc_to_replace[value] = i
        i += 1
    
    return data_map_table, dicc_to_replace

def normalize_values(df, df_column, dicc_to_replace):
    df[df_column] = df[df_column].replace(to_replace=dicc_to_replace)
    return df